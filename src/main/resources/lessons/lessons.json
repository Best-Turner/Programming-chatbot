[{"id":2,"title":"Инкапсуляция","description":"Цель инкапсуляции – улучшить качество взаимодействия вещей за счет упрощения их","content":"С точки зрения программирования, инкапсуляция – это «сокрытие реализации». Мне нравится такое определение. Наш класс может содержать сотни методов и реализовывать очень сложное поведение в различных ситуациях. Но мы можем скрыть от посторонних глаз все его методы (пометить модификатором private), а для взаимодействия с другими классами оставить всего пару-тройку методов (пометить их модификатором public). Тогда все остальные классы нашей программы будут видеть в этом классе всего три метода, и будут вызывать именно их. А все сложности будут скрыты внутри класса, как кабина пилотов от счастливых пассажиров.","topic":"ООП"},{"id":3,"title":"Наследование","description":"наследование – это специальное отношение между двумя классами","content":"В программировании тоже есть возможность создавать один класс на основе другого. Новый класс становится потомком (наследником) уже существующего. Это очень выгодно, когда есть класс, который содержит 80%-90% нужных нам данных и методов. Мы просто объявляем подходящий класс родителем нашего нового класса, тогда в новом классе автоматически появляются все данные и методы класса-родителя.","topic":"ООП"},{"id":4,"title":"Полиморфизм","description":"Оно описывает ситуацию, когда за одним интерфейсом скрываются разные реализации","content":"Если постараться поискать его аналоги в реальной жизни, то одним из таких аналогов будет процесс управления машиной.\n\nЕсли человек может управлять грузовиком, то его можно посадить и за руль скорой, и за руль спорткара. Человек может управлять машиной вне зависимости от того, что это за машина, потому что все они имеют одинаковый интерфейс управления: руль, педали и рычаг коробки передач. Внутреннее устройство машин разное, но все они имеют одинаковый интерфейс управления.\n\nЕсли вернуться к программированию, то полиморфизм позволяет единообразно обращаться к объектам различных классов (обычно имеющих общего предка) – вещь, которую трудно переоценить. Ценность его тем выше, чем больше программа.","topic":"ООП"},{"id":5,"title":"Синтаксис","description":"это основа языка, все основные правила, команды, а также конструкции для написания программ","content":"Эта статья посвящена базовому синтаксису языка программирования Java и нацелена на тех, кто изучает Java, начинающих разработчиков или тех, кто знает другой язык программирования. Некоторые аспекты могут быть непонятны новичкам. Если такое случится с вами, рекомендуем пропустить сложные части и сосредоточиться на примерах. Как и во всем остальном, язык программирования лучше изучать циклично, постепенно приходя к более глубокому пониманию тех или иных понятий.\n\nКаждая Java-программа — это по сути набор объектов, которые включают данные (переменные) и поведение (функции или методы). Также программа Java представляет собой класс или несколько классов. Объект — это экземпляр класса. Класс — это модель например, формочки для печенья, а объекты — печенье. Или, скажем, класс — это абстрактный «Java-программист», а объект — «Java-программист Иван» или «Java-программист Алиса».\nОбъекты в Java\nОбъекты в Java имеют состояния и поведение.\n\nВот вам пример. У кота есть состояния: его зовут Барсик, окрас рыжий, владелец Иван. У кота также есть поведение: сейчас Барсик спит. Он также может мурлыкать, ходить и так далее. Объект является экземпляром класса.\nКласс в Java\nКласс — это модель, шаблон или чертеж объекта. Он описывает поведение и устанавливает, что поддерживает объект его типа. Например, у класса Cat есть собственное имя, цвет, владелец; у кота также есть поведение: прием пищи, мурлыканье, ходьба, сон.\nМетоды в Java\nМетоды предназначены для описания логики, работы с данными и выполнения всех действий. Каждый метод определяет поведение. Класс может содержать множество методов. Например, мы можем написать метод sleep() для класса Cat (чтобы спать) или purr() для мурлыканья.\nПеременные экземпляра в Java\nУ каждого объекта есть уникальный набор переменных экземпляра. Состояние объекта обычно формируется значениями, которые присваиваются этим переменным экземпляра. Например, имя или возраст кошки могут быть перемеными.\n","topic":"Синтаксис"},{"id":6,"title":"Циклы в Java","description":"Циклы — это разновидность управляющих конструкций для организации многократного выполнения одного и того же участка кода","content":"Код внутри такой управляющей конструкции выполняется циклично. Каждое выполнение кода — это итерация цикла. Количество итераций регулируется условием цикла. Код, который выполняется внутри цикла, называют телом цикла.  \n\nИзвестны такие виды циклов: \nЦиклы с предусловием: условие выполнения определяется перед первой итерацией.\n\nЦиклы с постусловием: условие выполнения определяется после первой итерации (поэтому они всегда выполняются минимум один раз). Полезны, когда нужно выполнять некое действие, пока не реализуется некое условие: например, считывать ввод пользователя, пока он не введет слово “stop”.\n\nЦиклы со счетчиком: количество итераций определяется смоделированным счетчиком. В условии цикла задается его начальное и конечное значение. Каждую итерацию счетчик наращивается. Мы можем заранее определить количество итераций.\n\nЭти циклы бывают полезны, когда нужно перебрать все элементы в какой-то коллекции. Циклы со счетчиком называют “циклами для...”. “Для каждого элемента некоторой коллекции осуществить следующие действия”.\n\nДопустимы случаи, когда выполнение цикла можно прервать до достижения его условия. Например, если у нас есть коллекция из 100 чисел и нам необходимо понять, содержит ли она отрицательные числа. Мы можем начать перебор всех чисел, используя цикл “для”. Но когда мы найдем первое отрицательное число, нам не обязательно перебирать оставшиеся числа. Мы можем прервать выполнение цикла, если его дальнейшее выполнение не имеет смысла. Подобные ситуации называют прерыванием цикла.\n\nБезусловные циклы — циклы, которые выполняются бесконечно. Например: “Пока 1=1, печатать “1=1””. Такая программа будет выполняться, пока ее вручную не прервут.\n\nДанные циклы тоже бывают полезны, когда используются вместе с прерыванием цикла “изнутри”. Используйте их осторожно, чтобы не спровоцировать зависание программы.","topic":"Циклы"},{"id":7,"title":"Массивы в Java","description":"Массив — это структура данных, в которой хранятся элементы одного типа. Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку)","content":"В случае с Java массив однороден, то есть во всех его ячейках будут храниться элементы одного типа. Так, массив целых чисел содержит только целые числа (например, типа int), массив строк — только строки, массив из элементов созданного нами класса Dog будет содержать только объекты Dog. То есть в Java мы не можем поместить в первую ячейку массива целое число, во вторую String, а в третью — “собаку”. \nМассивы в Java\nОбъявление массива\nКак объявить массив?\nКак и любую переменную, массив в Java нужно объявить. Сделать это можно одним из двух способов. Они равноправны, но первый из них лучше соответствует стилю Java. Второй же — наследие языка Си (многие Си-программисты переходили на Java, и для их удобства был оставлен и альтернативный способ). В таблице приведены оба способа объявления массива в Java:   \n№\tОбъявление массива, Java-синтаксис\tПримеры\tКомментарий\n1.\t\ndataType[] arrayName;\nint[] myArray;\n\nObject[]\narrayOfObjects;\nЖелательно объявлять массив именно таким способом, это Java-стиль\n2.\t\ndataType arrayName[];\nint myArray[];\n\nObject\narrayOfObjects[];\nУнаследованный от С/С++ способ объявления массивов, который работает и в Java\nВ обоих случаях dataType — тип переменных в массиве. В примерах мы объявили два массива. В одном будут храниться целые числа типа int, в другом — объекты типа Object. Таким образом при объявлении массива у него появляется имя и тип (тип переменных массива). arrayName — это имя массива. \nСоздание массива\nКак создать массив?\nКак и любой другой объект, создать массив Java, то есть зарезервировать под него место в памяти, можно с помощью оператора new. Делается это так: \n\nnew typeOfArray [length];\n\nГде typeOfArray — это тип массива, а length — его длина (то есть, количество ячеек), выраженная в целых числах (int). Однако здесь мы только выделили память под массив, но не связали созданный массив ни с какой объявленной ранее переменной","topic":"Массивы"},{"id":8,"title":"ArrayList в Java","description":"ArrayList — реализация изменяемого массива интерфейса List","content":"В основе ArrayList лежит идея динамического массива. А именно, возможность добавлять и удалять элементы, при этом будет увеличиваться или уменьшаться по мере необходимости.\nЧто хранит ArrayList?\nТолько ссылочные типы, любые объекты, включая сторонние классы. Строки, потоки вывода, другие коллекции. Для хранения примитивных типов данных используются классы-обертки.\nКонструкторы ArrayList\nArrayList()\n\nПустой конструктор с начальной емкостью внутреннего массива = 10.\n\nArrayList<String> list = new ArrayList<>();\nВ угловых скобках желательно указать тип хранимых значений. В примере выше — String.\n\nArrayList(Collection <? extends E> c)\n\nКонструктор принимает другую коллекцию, создавая новый массив с элементами переданной коллекции:\n\nArrayList<String> list2 = new ArrayList<>(list);\nПорядок элементов в новом списке будет совпадать с исходным.\n\nArrayList(int initialCapacity)\n\nВ качестве параметра конструктора выступает значения начального размера внутреннего массива.\n\nArrayList<String> list2 = new ArrayList<>(10000);\nЕсли в массиве, который лежит в основе ArrayList, закончилось место при добавлении новых элементов, создается новый массив большего размера, и данные копируются в него. Если при написании кода заранее известно, что в массиве будет обрабатываться большое количество элементов, в целях оптимизации следует указать большее значение.\n\nМетоды ArrayList\nНиже представлены основные методы ArrayList.\n\nadd(E e)\n\nДобавляет новый элемент в конец списка. Возвращает boolean-значение (true — успех, false — не добавлено):\n\nArrayList<String> list = new ArrayList<>();\nlist.add(\"Hello\");\nadd(int index, E element)\n\nДобавляет элемент element в позицию index. При добавлении происходит сдвиг всех элементов справа от указанного индекса на 1 позицию вправо:\n\nlist.add(0, \"Amigo\");\nОчень полезен, когда нужно вставить элемент в произвольное место списка, однако для частых операций вставки в начало и середину ArrayList может оказаться не очень удачным выбором — следует изучить LinkedList.\n\naddAll(Collection <? extends E> collection)\n\nДобавление всех элементов коллекции collection в список в порядке их расположения в collection.\n\naddAll(int index, Collection <? extends E> collection)\n\nДобавление всех элементов collection в список начиная с индекса index. При этом все элементы сдвинутся вправо на количество элементов в списке collection:\n\nArrayList<String> secondList = new ArrayList<>();\nsecondList.addAll(list);\nSystem.out.println(\"Первое добавление: \" + secondList);\nsecondList.addAll(1, list);\nSystem.out.println(\"Второе добавление в середину: \" + secondList);\nВывод:\n\nПервое добавление: [Amigo, Hello]\nВторое добавление в середину: [Amigo, Amigo, Hello, Hello]","topic":"Списки"},{"id":9,"title":"Set в Java","description":"коллекция Set создана для хранения множества элементов","content":"Операции над множеством\n\nС множеством можно делать только три операции: добавлять элементы во множество, удалять элементы из множества и проверять, есть ли во множестве определенный элемент. Все.\n\nОтсутствие порядка\n\nУ элементов этой коллекции нет номеров. Нельзя получить элемент по его индексу или записать значение в коллекцию по определенному индексу. Методов get() и set() у множества нет.\n\nУникальность элементов\n\nВсе элементы множества уникальны. В отличие от списка, во множестве один элемент может быть только раз. Объект или находится во множестве, или нет: третьего не дано. Нельзя во «множество цветов» трижды добавить «черный цвет». Он там либо есть, либо его нет.\n\nПоиск элементов\n\nКогда вы добавляете во множество новый элемент, удаляете элемент, или проверяете наличие элемента, внутри метода выполняется поиск элемента. Элементы коллекции и переданный элемент сравниваются сначала по hashCode(), а если hashCode() совпадают, по equals.","topic":"Множества"},{"id":10,"title":"String","description":"Класс String в Java предназначен для работы со строками в Java","content":"Все строковые литералы, определенные в Java программе (например, \"abc\") — это экземпляры класса String. Давай посмотрим на его ключевые характеристики: \nКласс реализует интерфейсы Serializable и CharSequence. Поскольку он входит в пакет java.lang, его не нужно импортировать.\nКласс String в Java — это final класс, который не может иметь потомков.\nКласс String — immutable класс, то есть его объекты не могут быть изменены после создания. Любые операции над объектом String, результатом которых должен быть объект класса String, приведут к созданию нового объекта.\nБлагодаря своей неизменности, объекты класса String являются потокобезопасными и могут быть использованы в многопоточной среде.\nКаждый объект в Java может быть преобразован в строку через метод toString, унаследованный всеми Java-классами от класса Object.\nКласс String в Java - 1\nРабота с Java String\nЭто один из самых часто используемых классов в Java. В нем есть методы для анализа определенных символов строки, для сравнения и поиска строк, извлечения подстрок, создания копии строки с переводом всех символов в нижний и верхний регистр и прочие. Список всех методов класса String можно изучить в официальной документации.\n\nТакже в Java реализован несложный механизм конкатенации (соединения строк), преобразования примитивов в строку и наоборот. \n\nДавай рассмотрим некоторые примеры работы с классом String в Java. \nСоздание строк\nПроще всего создать экземпляр класса String, присвоив ему значение строкового литерала: \n\nString s = \"I love movies\";\n\nОднако у класса String есть много конструкторов, которые позволяют:\nсоздать объект, содержащий пустую строку\nсоздать копию строковой переменной\nсоздать строку на основе массива символов\nсоздать строку на основе массива байтов (с учетом кодировок)\nи т.д.\nСложение строк\nСложить две строки в Java довольно просто, воспользовавшись оператором +. Java позволяет складывать друг с другом и переменные, и строковые литералы: \n\npublic static void main(String[] args) {\n    String day = \"День\";\n    String and = \"и\";\n    String night = \"Ночь\";\n\n    String dayAndNight = day + \" \" + and + \" \" + night;\n}\n","topic":"Строки"}]